package server;

import java.awt.*;
import java.io.*;
import java.net.*;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Random;


public class TFTPServer implements Runnable {

    private DatagramSocket socket;
    private DatagramPacket packet;
    private DatagramPacket receivedPacket;
    private int portNum;
    private String filename;

    private ByteArrayInputStream byteArrayInputStream;
    private ByteArrayOutputStream byteArrayOutputStream;
    private FileInputStream fileInputStream;
    private FileOutputStream fileOutputStream;
    private byte[] opcode = new byte[2];

    int expectedBlockNum;
    boolean finishedRequest = false;

    private static final byte RRQ = 1;
    private static final byte WRQ = 2;
    private static final byte DATA = 3;
    private static final byte ACK = 4;
    private static final byte ERROR = 5;

    private InetAddress clientIP;
    private int clientPort;

    Random random = new Random();
    private int blockNum;

    public TFTPServer(DatagramPacket packet) throws SocketException {
        this.portNum = random.nextInt(65535 - 1025) + 1025;
        receivedPacket = packet;
        socket = new DatagramSocket(portNum);
        socket.setSoTimeout(5000);
    }

    @Override
    public void run() {

        byte[] data = new byte[516];
        boolean initialPacket = true;

        try {
            while (!finishedRequest) {
                if (!initialPacket) {
                    receivedPacket = new DatagramPacket(data, 516);
                    socket.receive(receivedPacket);
                }
                byteArrayInputStream = new ByteArrayInputStream(receivedPacket.getData());
                byteArrayInputStream.read(opcode, 0, 2);
                clientIP = receivedPacket.getAddress();
                clientPort = receivedPacket.getPort();
                initialPacket = false;
                if (findOpCode(opcode) == 1) {
                    System.out.println("received RRQ");
                    blockNum = 0;
                    boolean fileFound;
                    try {
                        extractFileName();
                        fileInputStream = new FileInputStream(filename);
                        fileFound = true;
                    } catch (FileNotFoundException e) {
                        sendError(new byte[]{0, 1}, "ERROR: File not Found");
                        fileFound = false;
                        finishedRequest = true;
                        socket.close();
                    }
                    if (fileFound) {
                        byteArrayOutputStream = new ByteArrayOutputStream();
                        boolean finished = false;
                        int currentByte;
                        while (!finished) {
                            currentByte = fileInputStream.read();
                            if (currentByte == -1) {
                                finished = true;
                            } else {
                                byteArrayOutputStream.write(currentByte);
                            }
                        }
                        byte[] holdBytes = byteArrayOutputStream.toByteArray();
                        fileInputStream.close();
                        if (holdBytes.length <= 512) {
                            blockNum++;
                            sendData(blockNum, holdBytes);
                            if (holdBytes.length == 512){
                                byte[] emptyData = new byte[0];
                                blockNum++;
                                sendData(blockNum, emptyData);
                            }
                        } else {
                            int fullPackets = holdBytes.length / 512;
                            int lenFinalPacket = holdBytes.length % 512;
                            int totalBytesRead = 0;
                            byte[] dataToSend = new byte[512];
                            byte[] finalPacket = new byte[lenFinalPacket];
                            for (int i = 0; i < fullPackets; i++) {
                                for (int j = 0; j < 512; j++) {
                                    dataToSend[j] = holdBytes[totalBytesRead];
                                    totalBytesRead++;
                                    if (j == 511) {
                                        blockNum++;
                                        sendData(blockNum, dataToSend);
                                    }
                                }
                            }
                            if (lenFinalPacket != 0) {
                                for (int i = 0; i < lenFinalPacket; i++) {
                                    finalPacket[i] = holdBytes[totalBytesRead];
                                    totalBytesRead++;
                                }
                                blockNum++;
                                sendData(blockNum, finalPacket);
                            } else {
                                byte[] emptyData = new byte[0];
                                blockNum++;
                                sendData(blockNum, emptyData);
                            }
                        }
                        System.out.println("File transfer complete");
                        finishedRequest = true;
                        socket.close();
                    }

                } else if (findOpCode(opcode) == 2) {
                    blockNum = 0;
                    expectedBlockNum = 1;
                    extractFileName();
                    sendAck(blockNum);
                    fileOutputStream = new FileOutputStream(filename);

                } else if (findOpCode(opcode) == 3) {
                    byte[] blockNumber = new byte[2];
                    byteArrayInputStream.read(blockNumber, 0, 2);
                    if (blockNumberToDecimal(blockNumber[0], blockNumber[1]) == expectedBlockNum) {
                        int currentByte;
                        int bytesRead = 0;
                        while ((currentByte = byteArrayInputStream.read()) != -1) {
                            if (currentByte != 0) {
                                fileOutputStream.write(currentByte);
                                bytesRead++;
                            }
                        }
                        blockNum++;
                        expectedBlockNum++;
                        sendAck(blockNum);
                        if (bytesRead != 512) {
                            fileOutputStream.close();
                            System.out.println(filename + " Successfully stored!");
                            socket.close();
                            finishedRequest = true;
                        }
                    }
                }
            }
        } catch (IOException ex) {

        }
    }

    public void sendAck(int blockNum) throws IOException {
        byte[] ackToSend = new byte[4];
        ackToSend[0] = 0;
        ackToSend[1] = 4;
        ackToSend[2] = (blockNumAsByteArray(blockNum)[0]);
        ackToSend[3] = (blockNumAsByteArray(blockNum)[1]);
        sendPacket(ackToSend, ackToSend.length, clientIP, clientPort);
    }

    /**
     * Method to send a data packet. Takes in the current block number and a byte array up to a length of 512. A new
     * byte array is created and the opcode in inserted first then the block number is converted into bytes using
     * the blockNumAsByteArray method and inserted after and finally the byte array with the data to be sent is copied
     * in. The packet is a assembled and sent using the sendPacket method.     *
     * @param blockNumber
     * @param dataToSend
     * @throws IOException
     */
    public void sendData(int blockNumber, byte[] dataToSend) throws IOException{
        boolean receivedAck = false;
        int length = dataToSend.length + 4;
        byte[] dataPckToSend = new byte[length];
        dataPckToSend[0] = 0;
        dataPckToSend[1] = 3;
        dataPckToSend[2] = blockNumAsByteArray(blockNumber)[0];
        dataPckToSend[3] = blockNumAsByteArray(blockNumber)[1];
        for (int i = 0; i < dataToSend.length; i++){
            dataPckToSend[i+4] = dataToSend[i];
        }
        sendPacket(dataPckToSend, dataPckToSend.length, clientIP, clientPort);
        System.out.println(dataPckToSend.length);
        while (!receivedAck){
            try {
                byte[] receiveAck = new byte[516];
                receivedPacket = new DatagramPacket(receiveAck, receiveAck.length);
                socket.receive(receivedPacket);
                byteArrayInputStream = new ByteArrayInputStream(receivedPacket.getData());
                byteArrayInputStream.read(opcode, 0, 2);
                if (opcode[1] == 4) {
                    receivedAck = true;
                }
            }   catch (SocketTimeoutException e) {
                System.out.println("Socket Timed out will retry");
                sendPacket(dataPckToSend, dataPckToSend.length, clientIP, clientPort);
            }
        }
    }

    public void sendError(byte[] errCode, String errMsg) throws IOException{
        byte[] errMsgBytes = errMsg.getBytes(StandardCharsets.UTF_8);
        byte[] errPckToSend = new byte[errMsgBytes.length + 4];
        errPckToSend[0] = 0;
        errPckToSend[1] = 5;
        errPckToSend[2] = errCode[0];
        errPckToSend[3] = errCode[1];
        for (int i = 0; i < errMsgBytes.length; i++) {
            errPckToSend[i+4] = errMsgBytes[i];
        }
        sendPacket(errPckToSend, errPckToSend.length, clientIP, clientPort);
    }

    /**
     * Method to create then send a packet, takes in all information needed to send a packet, creates it and then sends.
     * A socket timeout is included.
     * @param dataToSend
     * @param length
     * @param ip
     * @param port
     * @throws IOException
     */
    public void sendPacket(byte[] dataToSend, int length, InetAddress ip, int port) throws IOException {
        packet = new DatagramPacket(dataToSend, length, ip, port);
        socket.send(packet);
    }

    /**
     * Method to convert the block number into a 2 byte array. The byte of
     * @param blockNum
     * @return
     */
    public byte[] blockNumAsByteArray(int blockNum) {
        byte[] blockNumByteArr = new byte[2];
        blockNumByteArr[0] = (byte) (blockNum & 0xFF);
        blockNumByteArr[1] = (byte) ((blockNum >> 8) & 0xFF);
        return blockNumByteArr;
    }

    public void extractFileName() throws IOException {
        ByteArrayOutputStream fileNameBytes = new ByteArrayOutputStream();
        int fileNameByte;
        while ((fileNameByte = byteArrayInputStream.read()) != 0) {
            fileNameBytes.write(fileNameByte);
        }
        filename = fileNameBytes.toString();
        byteArrayInputStream.close();
        fileNameBytes.close();
    }

    /**
     *Method takes a byte array of length two which will be the opcode taken from a received packet
     * and returns the opcode number as an integer.
     * @param opCode
     * @return an integer 1-5 depending on the opcode given to the method
     */
    public int findOpCode(byte[] opCode) {
        if (opCode[1] == 1){
            return 1;
        } else if (opCode[1] == 2){
            return 2;
        } else if (opCode[1] == 3){
            return 3;
        } else if (opCode[1] == 4){
            return 4;
        } else return 5;
    }

    public int blockNumberToDecimal(byte a, byte b) {
        String a1 = Integer.toBinaryString(a);
        String b1 = Integer.toBinaryString(b);
        String c = b1 + a1;
        return Integer.parseInt(c, 2);
    }
}
